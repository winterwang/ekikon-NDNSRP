---
title: "Mining the National Diet and Nutrition Survey Rolling Programme (NDNS RP) data"
subtitle: "Where, when, what you eat."
author: "王　超辰 | Chaochen Wang"
date: "2019-09-17 18:00~19:30 @AMU・疫学懇話会"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    lib_dir: libs
    nature:
      countdown: 60000
      highlightStyle: github
      highlightLines: true
      highlightSpans: true
      countIncrementalSlides: false
---


```{r xaringan-themer, include = FALSE}
library(xaringanthemer)
mono_light(
  base_color = "#1c5253",
  header_font_google = google_font("Josefin Sans"),
  # text_font_google   = google_font("M PLUS Rounded 1c", "300", "300i"),
  text_font_google = google_font("Noto Sans JP", "300", "300i"), 
  code_font_google   = google_font("Droid Mono"),
  text_bold_color = "#B03A2E",
  link_color = "#2c7fb8",
  title_slide_background_image = "pic/",
  inverse_text_shadow = TRUE
)
# write_xaringan_theme(text_bold_color = "#FF4333")
```

class: middle

# Outline of today's talk 

--
### Correspondence analyses:


- Relationship between **food consumed** and **eating location** for UK adolescents


- Relationship between **food consumed** and **eating time** for UK adults according to their diabetes status 

--

### Multilevel Latent Class Analysis:

- Relationship between **carbohydrate consumption** and **eating time** for UK adults. 

---
class: middle

# Some intuition about correspondence analysis  (CA)

--
- CA is a method for investigating the relationship in a **two-dimensional contingency table**.

- For example, the following table gives the frequency of consumption of three healthy food groups at each location in the NDNS RP data among teenagers (age: 11~19 years):

```{r eval = T, echo=FALSE, message=FALSE}
library(knitr)
library(kableExtra)
library(tidyverse)
load("../CA-NDNSRP/H_teenFood.Rdata")

TableFoogGroup <- H_teenFood %>% 
  ungroup() %>% 
  group_by(mfgLab) %>% 
  summarise(n = n(), meanHpoint = mean(H_points, na.rm = T), mfgCalories = sum(Energykcal)) %>% 
  arrange(-mfgCalories) %>% 
  mutate(n.freq = paste0(round(100 * n/sum(n), 2), "%"))  %>% 
  mutate(cal.Prop = paste0(round(100 * mfgCalories/sum(mfgCalories), 2), "%"))  %>% 
  mutate(calprop = mfgCalories/sum(mfgCalories)) %>% 
  mutate(calcumprop = paste0(round(100 * cumsum(calprop), 3), "%")) %>% 
  select(-calprop) 


TableFoogGroup <- TableFoogGroup %>% 
  mutate(healthy     = meanHpoint < -2, 
         lesshealthy = meanHpoint > 4, 
         neutral     = (meanHpoint <= 4) & (meanHpoint >= -2))

# TableFoogGroup %>% 
#   filter(healthy) %>% 
#   select(-lesshealthy, -neutral, -calcumprop, -healthy)
healthyfg <- H_teenFood %>% 
  filter(mfgLab %in% c("Fruit", "Veg not raw", "Brown Bread"))
freqtab <- xtabs(~healthyfg$mfgLab + healthyfg$Locat_type)
freqtabmg <- addmargins(freqtab)
as.data.frame.matrix(freqtabmg) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 
```


---
class: middle 

## Usually, we will conduct a $\chi^2$ test. 

```{r eval = T, echo=FALSE, message=FALSE}
as.data.frame.matrix(freqtabmg) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 
```


$$
\chi^2 = \sum\frac{(\text{Observed} - \text{Expected})^2}{\text{Expected}} \sim \chi^2_{(m -1)\times(n-1)}
$$

--
### To look for evidence against the null hypothesis that **there is no difference across the columns or rows**.

---
class: middle
# Hypothesis of independence

The null hypothesis of no difference across the columns or rows is also called:

.pull-left[
- Hypothesis of independence 
]

.pull-right[
- Homogeneity assumption
]

```{r}
chisq.test(freqtab)
```


We conclude that **there is dependency between the columns (food groups) and the rows (locations)**. 

---
class: middle

## But what exactly does this dependency mean?


```{r eval = T, echo=FALSE, message=FALSE}
as.data.frame.matrix(freqtabmg) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"))%>% 
  column_spec(1, bold = T) 
```

### Can we get **more information** from this contingency table? How?

--
### Yes! we can visualize their relationships!


---
class: middle 

## Step 1 - convert the frequency cell to proportions

```{r echo = FALSE}
Xp <- as.matrix(freqtab) / sum(as.matrix(freqtab))
Xpmg <- addmargins(Xp)
Xpmg <- signif(Xpmg, digits = 3)

Xp_4 <- sprintf("%.4f", Xpmg)
Xp_4 <- matrix(Xp_4, nrow = 4)
row.names(Xp_4) <- c("Brown Bread", "Fruit", "Veg not raw", "c: col masses")
colnames(Xp_4) <- c("Others", "Home", "School_work", "r: row masses")

as.data.frame.matrix(Xp_4) %>%
  kable(caption = "Matrix X. Observed Cell Proportions") %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 
```

- Row masses: $\mathbf{r} = \mathbf{X1}$ 

```{r}
r <- Xp %*% matrix(c(1, 1, 1), nrow = 3)
```

- Column masses: $\mathbf{c} = \mathbf{X}^T\mathbf{1}$

```{r}
c <- t(Xp)  %*% matrix(c(1, 1, 1), nrow = 3)
```

---
class: middle 
## Step 2 - The variation (residuals) of each cell in matrix X from its expected value

$$\text{Deviation} = \mathbf{X} - \mathbf{rc}^T$$

```{r echo=FALSE}
Deviation <- Xp - r %*% t(c)
library(formattable)
Deviation <- addmargins(Deviation)
Dev <- sprintf("%.5f", Deviation)
Dev <- matrix(Dev, nrow = 4)
rownames(Dev) <- rownames(Deviation)
colnames(Dev) <- colnames(Deviation)
as.data.frame.matrix(Dev) %>%
  kable(caption = "Deviations from Expected") %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 
```

Big positive (negative) numbers means a strong positive (negative) relationship.

???
The residuals quantify the difference between the observed data and the data we would expect under the assumption that there is no relationship between the row and column categories of the table.

---
class: middle

## Step 3 - Standardise the residual for fair comparison (Z score)

$$
\mathbf{Z}  = \mathbf{D}_r^{-\frac{1}{2}} \times \text{Deviation} \times \mathbf{D}_c^{-\frac{1}{2}}
$$
```{r eval=TRUE, echo=FALSE}
Deviation <- Xp - r %*% t(c)
Dr <- diag(as.numeric(r))
Dc <- diag(as.numeric(c))
z <- solve(expm::sqrtm((Dr))) %*% Deviation %*% solve(expm::sqrtm((Dc)))

Z_name <- sprintf("%.5f", z)
Z_name <- matrix(Z_name, nrow = 3)
rownames(Z_name) <- c("Brown Bread", "Fruit", "Veg not raw")
colnames(Z_name) <- c("Others", "Home", "School_work")
as.data.frame.matrix(Z_name) %>%
  kable(caption = "Standardised Residuals Table") %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 
```


???
These standardized residuals are z-scores.  This means that values of more than 1.96, or less than -1.96, are significant at the 0.05 level. For binary variables, their standard deviation is the square root of their expected values. 


---
class: middle

## Step 4 - Single Value Decomposition

$$
\mathbf{Z} = \mathbf{UD}_\lambda \mathbf{V}^T
$$

Where, 

- $\mathbf{Z}$: the standardised deviation matrix; 
- $\mathbf{U}$: the left singular vectors of $\mathbf{Z}$ <br> (principal axes of food groups space **for projection of locations**); 
- $\mathbf{D}_\lambda$: singular values matrix;
- $\mathbf{V}^T$: right singular vectors of $\mathbf{Z}$<br> (principal axes of location space **for projection of food groups**).

--
#### Reminder in principle component analysis (PCA)  - Spectral decomposition

$$
\mathbf{S} = \mathbf{P}\Lambda\mathbf{P}^T
$$

#### It is easy to prove that 

$$
\mathbf{D}_\lambda^2 = \Lambda
$$

???

- S is the variance covariance matrhx 
- Lambda is the diagonal eigenvalue matrix 
- P is orthogonal projection matrix with new coordinates for the rotated new variables

---
class: middle
## Step 4 - Single Value Decomposition

$$
\begin{aligned}
\mathbf{Z}  & = \mathbf{UD}_\lambda \mathbf{V}^T \\ 
\mathbf{Z}  & = \left[\begin{matrix}
0.00039&-0.032&0.083\\
0.02285&-0.071&0.162\\
-0.01694&0.064&-0.148
\end{matrix}\right] \\
= \left[\begin{matrix}
-0.34&0.8980&0.28\\
-0.69&-0.4400&0.57\\
0.63&0.0043&0.77
\end{matrix}\right]& 
\left(\begin{matrix}
0.26&0&0\\
0&0.01&0\\
0&0&0
\end{matrix}\right) 
\left[\begin{matrix}
-0.10&-0.94&0.32\\
0.39&0.26&0.88\\
-0.91&0.22&0.34
\end{matrix}\right]\\
\end{aligned}
$$

In R, simply do 

```{r, eval=FALSE}
svd(z)
```


---
class: middle 

## Step 5 - Calculate row profile, and column profile, centre them

.pull-left[

- Percentages of location for each food was eaten:

```{r echo=FALSE}
Dr <- diag(as.numeric(r))
Dc <- diag(as.numeric(c))
R <- solve(Dr) %*% Xp
C <- solve(Dc) %*% t(Xp)

Rmg <- addmargins(R)[-4,]
Rmg <- signif(Rmg, digits = 3)
rownames(Rmg) <- NULL

Rmg_4 <- sprintf("%.4f", Rmg)
Rmg_4 <- matrix(Rmg_4, nrow = 3)
rownames(Rmg_4) <- rownames(Rmg)
colnames(Rmg_4) <- colnames(Rmg)

as.data.frame.matrix(Rmg_4) %>%
  kable(caption = "Matrix R. Row Profile") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

$$
\begin{aligned}
\mathbf{R} & = \mathbf{D}^{-1}_r\mathbf{X} \\
\mathbf{R} &\; - \mathbf{1c}^T
\end{aligned}
$$
]

.pull-right[
- Percentages of food was eaten at each location:

```{r echo = FALSE}
C <- solve(Dc) %*% t(Xp)

Cmg <- addmargins(t(C))[,-4]
Cmg <- signif(Cmg, digits = 3)
colnames(Cmg) <- c("Others", "Home", "School")



Cmg_4 <- sprintf("%.4f", Cmg)
Cmg_4 <- matrix(Cmg_4, nrow = 4)
rownames(Cmg_4) <- rownames(Cmg)
colnames(Cmg_4) <- colnames(Cmg)


as.data.frame.matrix(Cmg_4) %>%
  kable(caption = "Matrix C. Column Profile") %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 
```
$$
\begin{aligned}
\mathbf{C} & = \mathbf{D}^{-1}_r\mathbf{X}^T \\
\mathbf{C} &\; - \mathbf{1r}^T
\end{aligned}
$$

]


---
class: middle 

## Step 6 - Find principal coordinates for rows and columns

.pull-left[
- Project the centred row profiles (food groups) onto to principal axes of locations $\mathbf{V}$
$$ 
F = (\mathbf{R} - \mathbf{1c}^T)(\mathbf{D}_c^{-1})(\mathbf{D}_c^{\frac{1}{2}}\mathbf{V})
$$

```{r echo = FALSE}

V <- svd(z)$v

CentR <- R - matrix(c(1, 1, 1), nrow = 3) %*% t(c)

## sqare root of matrix Dc
a.eig <- eigen(Dc)
Dc.sqrt <- a.eig$vectors %*% diag(sqrt(a.eig$values)) %*% solve(a.eig$vectors)

## row profile
F <-  CentR %*% solve(Dc) %*% (Dc.sqrt %*% V)



F_4 <- sprintf("%.4f", F)
F_4 <- matrix(F_4, nrow = 3)
F_4 <- F_4[, -3]
rownames(F_4) <-  c("Brown Bread", "Fruit", "Veg not raw")
colnames(F_4) <- c("Horizontal", "Vertical")
 

as.data.frame.matrix(F_4) %>%
  kable(caption = "Matrix F: Principal Coordinates for Rows") %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 
```
]

.pull-right[

- Project the centred column prifiles (locations) onto principal axes of food groups $\mathbf{U}$

$$ 
G = (\mathbf{C} - \mathbf{1r}^T)(\mathbf{D}_r^{-1})(\mathbf{D}_r^{\frac{1}{2}}\mathbf{U})
$$

```{r echo = FALSE}
U <- svd(z)$u

CentC <- C - matrix(c(1, 1, 1), nrow = 3) %*% t(r)


## sqare root of matrix Dr
a.eig <- eigen(Dr)
Dr.sqrt <- a.eig$vectors %*% diag(sqrt(a.eig$values)) %*% solve(a.eig$vectors)


## column profile 
G <- CentC %*% solve(Dr) %*% (Dr.sqrt %*% U)



G_4 <- sprintf("%.4f", G)
G_4 <- matrix(G_4, nrow = 3)
G_4 <- G_4[, -3]
rownames(G_4) <-  c("Others", "Home", "School_work")
colnames(G_4) <- c("Horizontal", "Vertical")
 

as.data.frame.matrix(G_4) %>%
  kable(caption = "Matrix G: Principal Coordinates for Columns") %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(1, bold = T) 

```


]


---
class: middle 

## Step 7 - standardise the coordinates


.pull-left[
$$
\text{Rows} = \mathbf{FD}_\lambda^{-\frac{1}{2}} \\
$$
]

.pull-right[
$$
\text{Columns} = \mathbf{G}\mathbf{D}_\lambda^{-\frac{1}{2}}
$$
]



```{r echo = FALSE}

## sqare root of matrix singular values
d.sqrt <- solve(expm::sqrtm(diag(svd(z)$d)))

Row <- F %*% d.sqrt
Row <- Row[, -3]
rownames(Row) <-  c("Brown Bread", "Fruit", "Veg not raw")
# c("Others", "Home", "School_work")
colnames(Row) <- c("Horizontal", "Vertical")

Colu <- G  %*% d.sqrt
Colu <- Colu[, -3]
rownames(Colu) <-   c("Others", "Home", "School_work")
colnames(Colu) <- c("Horizontal", "Vertical")

Coo <- rbind(Row, Colu)

Coo <- sprintf("%.4f", Coo)
Coo <- matrix(Coo, nrow = 6)
# G_4 <- G_4[, -3]
rownames(Coo) <-  c("Brown Bread", "Fruit", "Veg not raw", "Others", "Home", "School_work")
colnames(Coo) <- c("Horizontal", "Vertical")



as.data.frame.matrix(Coo) %>%
  kable(caption = "Standar Normalised Coordinates for Rows and Columns") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),  full_width = T) %>% 
  column_spec(1, bold = T) 

```

---
class: middle 

```{r include=FALSE}
source("makecaplot.R")
library(ca)
ca.fit <- ca(freqtab)
ca.plot <- plot(ca.fit)
```



```{r eval=TRUE, echo=FALSE, fig.height=8, fig.width=12, fig.align='center', warning=FALSE}

ca.plot.df <- make.ca.plot.df(ca.plot,
                              row.lab = "Food Groups",
                              col.lab = "Location")
ca.plot.df$Size <- ifelse(ca.plot.df$Variable == "Location", 2, 1)
ca.sum <- summary(ca.fit)
dim.var.percs <- ca.sum$scree[,"values2"]

library(ggplot2)
library(ggrepel)

p <- ggplot(ca.plot.df, aes(x = Dim1, y = Dim2,
                       col = Variable, shape = Variable,
                       label = Label, size = Size)) +
  geom_vline(xintercept = 0, lty = "dashed", alpha = .5) +
  geom_hline(yintercept = 0, lty = "dashed", alpha = .5) +
  geom_point() +
  scale_x_continuous(limits = range(ca.plot.df$Dim1) + c(diff(range(ca.plot.df$Dim1)) * -0.2,
                                                         diff(range(ca.plot.df$Dim1)) * 0.2)) +
  scale_y_continuous(limits = range(ca.plot.df$Dim2) + c(diff(range(ca.plot.df$Dim2)) * -0.2,
                                                         diff(range(ca.plot.df$Dim2)) * 0.2)) +
  scale_size(range = c(4, 7)) +
  geom_label_repel(show.legend = FALSE, segment.alpha = .5, point.padding = unit(5, "points")) +
  labs(x = paste0("Dimension 1 (", signif(dim.var.percs[1], 3), "%)"),
       y = paste0("Dimension 2 (", signif(dim.var.percs[2], 3), "%)"),
       col = "", shape = "") +
  theme_minimal() + theme(plot.caption = element_text(size = 12, 
    face = "bold"), panel.grid.major = element_line(colour = "lightgray", 
    size = 0.6, linetype = "dotted"), panel.grid.minor = element_line(size = 1.6, 
    linetype = "dotted"), axis.title = element_text(size = 18), 
    axis.text = element_text(size = 15, colour = "gray0"), 
    plot.title = element_text(size = 21, 
        face = "bold", hjust = 0.5, vjust = 2), 
    panel.background = element_rect(fill = "white", 
        size = 0), legend.position = "none") +labs(title = "Correspondence Analysis of food groups and locations", 
    colour = NULL, shape = NULL, caption = "Coordinates in symmetric normalization")
plot(p)
```


---
class: middle


